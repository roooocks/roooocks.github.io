---
title: 삽입 정렬
description: 데이터가 어느정도 정렬되어있는 상황이라면 고려해보자!
date: 2024-09-04 15:52:11 +0900
categories: [프로그래밍 이론, 알고리즘]
tags: [기술정리, 구현, 정렬]
math: true
---

**윤성우의 열혈 자료구조**를 참고했습니다.

## 요약
- 시간 복잡도
  - 비교연산 횟수 : $O(n^2)$
  - 대입연산(위치 변경을 위한 데이터 이동) 횟수 : $O(n^2)$
- 특징
  - 데이터가 크면 클수록 기하급수적으로 느려진다.
  - <ins>데이터가 어느정도 정렬</ins>되어있으면 <ins>급 효율적이게 변한다!</ins>
  - 구현이 간단하다.
- 작동 방식
  - 길이 N의 배열이 있을 경우 두번째 데이터가 첫번째 데이터, 세번째 데이터가 두번째 데이터부터 첫번째 데이터, ... , N번째 데이터가 (N - 1) 데이터부터 첫번째 데이터까지 순서대로 정렬 우선순위를 비교해서 정렬할 데이터의 삽입 위치를 찾는다.
    - 비교한 데이터의 정렬 우선순위가 낮은 경우 : 해당 위치의 데이터를 뒤로 옮긴다.
    - 비교한 데이터의 정렬 우선순위가 높은 경우 : <ins>비교를 멈추고 바로 전에 비교한 데이터의 위치에 정렬할 데이터를 삽입</ins>한다. 바로 전에 비교한 데이터가 없다(첫 비교)면 정렬할 데이터의 위치는 바뀌지 않는다.
    - 비교한 데이터의 정렬 우선순위가 같을 경우 : 데이터를 옮겨도되고 안옮겨도 되고... (차이없음!)
  - 다만 비교한 데이터가 첫번째 데이터일 경우는 살짝 달라진다.
    - 정렬 우선순위가 낮은 경우 : 데이터를 뒤로 옮기는건 같으나 "비교한 데이터의 위치에 정렬할 데이터를 삽입한다."
  - 이걸 배열의 N번째까지 진행하면 정렬이 끝난다!
<br>


## 설명
삽입 정렬은 데이터를 한 칸씩 뒤로 밀면서 삽입할 위치를 찾고, 찾은 위치에 삽입함으로써 정렬이 되게하는 방식이다. <br>
길이 4를 가진 배열 { 4, 2, 1, 3 }을 오름차순 한다는걸로 예시로 들어보자. <br>
![Desktop View](https://lh3.googleusercontent.com/pw/AP1GczNdty_Uh6PLR0v1ZgYn1WJdZnnQTuz7icXdk_GPjo1WgWj9QTD9WYX1Sl75ydB5bNObVlepiyXOg-ZFYDOFhrUCgrKcQF1illYqDvNSIodCsR3SiwM=w2400){: }

<ins>비교한 데이터를 뒤로 옮기는 경우</ins>에는 <ins>정렬할 데이터가 없어지는 문제가 발생</ins>하는데, 그림처럼 <ins>정렬할 데이터의 값을 따로 저장</ins>하고 있으면 해결된다.


## 코드
```c
void InsertSort(int arr[], int n)
{
  int i, j;
  int insData;

  for (i = 1; i < n; i++)
  {
    insData = arr[i];

    for (j = i - 1; j >= 0; j--)
    {
      if (arr[j] > insData)
        arr[j + 1] = arr[j];
      else
        break;
    }

    arr[j + 1] = insData;
  }
}
```
