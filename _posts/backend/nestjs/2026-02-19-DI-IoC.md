---
title: DI / IoC 란?
description: 서비스를 생성하지 않았는데 왜 자동으로 주입될까?
date: 2026-02-19 14:35:00 +0900
categories: [백엔드, NestJS]
---

## 참고
- **[[코드팩토리] [초급] NestJS REST API 백엔드 완전 정복 마스터 클래스 - NestJS Core](https://www.inflearn.com/course/nestjs-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%99%84%EC%A0%84%EC%A0%95%EB%B3%B5-%EB%A7%88%EC%8A%A4%ED%84%B0-%ED%81%B4%EB%9E%98%EC%8A%A4-1)**
- ChatGPT와 티키타카
<br><br>



## 의존성 주입 (Dependency Injection)

### 일반적인 인스턴스 생성 방식
보통 A클래스가 B클래스를 사용한다면 아래와 같은 방식을 사용할 것이다.
```ts
class A {
  private b = new B();
}
```
{: file='A에서 B 사용하기' }

A 내부에 B를 직접 생성하고 A를 생성할 시 B도 함께 생성된다. 때문에 <ins>A가 B에 강하게 의존하는 구조</ins>라고 볼 수 있다.<br>
단순하게만 보면 `B 생성이 실패할 때 A 생성도 실패하기 때문`에 <ins>강하게 의존</ins>한다고 할 수 있지만 좀 더 정확히는 아래와 같은 이유가 있다.
- A는 B를 직접 생성한다.
- A는 B의 구체 구현을 알고 있다.
- A는 B의 구체 구현에 직접 의존하므로 다른 구현으로 교체하기 어렵다.
- A는 B의 구현이 바뀌면 함께 수정해야 한다.
- 여기서 말하는 **구체 구현**은 <ins>동작이 구현되어 있는 실제 클래스</ins>를 의미한다.
그렇기에 **A는 B에 강하게 의존하는 구조**라고 말할 수 있는 것이다.
<br>

### 의존성 주입 방식 (DI)
```ts
class A {
  constructor(private b: B) {}
}
```
{: file='DI 방식에서의 A에서 B 사용하기' }

B는 외부의 어딘가에서 생성되며, A가 생성될 때 B를 **주입** 받는다. 즉, <ins>A가 B를 직접 생성하지 않는다</ins>라는 것이다. <br>
핵심은 <ins>의존하고 있는 값을 외부에서 주입해준다</ins>인데, 좀 더 정확히는 아래와 같다.
- A는 B가 반드시 필요하다. (의존)
- 하지만 생성 책임은 A가 가지지 않는다. (책임의 외부 이동)
- A를 생성할 때 외부에서 B를 함께 넣어준다.
이걸 **의존성 주입(Dependency Injection)**이라고 한다.
<br><br>



## 제어의 역전 (Inversion of Control)
**Inversion of Control**은 <ins>Dependency Injection의 상위 개념</ins>이다. (좀 더 정확히는 DI가 IoC를 구현하는 여러 방법 중 하나이다.) <br>
차이점은 다른 클래스들이 의존하고 있는 이 <ins>인스턴스의 생성과 관리, 주입</ins>을 개발자가 아니라 **프레임워크**가 담당한다는 것이다. 실제로 NestJS에서는 서비스를 `new`로 직접 생성한 적이 없음에도 컨트롤러에 자동으로 주입되고 사용할 수 있는 것을 볼 수 있다.
```ts
@Controller('files')
export class FilesController {
  // 이렇게만 해도 서비스를 가져다 사용할 수 있게 된다.
  constructor(private readonly filesService: FilesService) {}

  @Get()
  getFiles() {
    return this.filesService.getAllFiles();
  }

  ...
}
```
{: file='내가 사용하는 NestJS 내용 중 일부' }

위와 같이 바로 사용할 수 있는 이유는 **IoC 컨테이너** 때문이다.
<br>

### IoC 컨테이너
NestJS는 실행과 동시에 **IoC 컨테이너**를 생성하는데, 아래와 같은 기능을 담당해준다.
- Provider 생성
- 의존성 분석
- 인스턴스가 필요한 곳에 자동 생성한 인스턴스를 자동 주입
  - 좀 더 정확히는 <ins>어플리케이션 부팅 시점</ins>에서 뭔가를 한다.
  - 근데 자세히 적으면 나중에 내가 봣을때 내 머리로는 모를게 뻔하니 필요하면 찾아서 보거라 미래의 나야
- 생명주기 관리(생성/삭제)

실제 예시를 대강적으로 들자면 "`클래스 A가 클래스 B를 필요로 함` > `IoC 컨테이너가 클래스 B 생성` > `A 생성자에 자동 주입`" 정도가 된다. <br>
때문에 우리는 인스턴스의 생성과 메모리 관리, 의존성 연결을 신경 쓸 필요가 없어지게 된다.
<br>

### Provider
IoC 컨테이너 설명 부분에서 Provider이라는 용어가 나왔다. <br>
의존성 주입이 되는 대상들을 통칭하는 용어로 대상의 종류는 아래와 같다.
- Service
- Repository
- Guard
- Pipe
- Interceptor
- 인증/검증 로직
- DB 통신 객체
<br><br>



## 코드로 이해하기

### Controller단
```ts
@Controller('files')
export class FilesController {
  constructor(private readonly filesService: FilesService) {}

  ...
}
```
{: file='*.controller.ts' }

FilesService를 생성하지 않았지만 위의 코드 부분에서 <ins>FilesService가 자동으로 주입</ins>된다. <br>
자동으로 주입이 되는 것을 담당하는 부분은 Module단에서 확인할 수 있다.
<br>

### Module단
```ts
...

@Module({
  controllers: [FilesController],
  providers: [FilesService],
})
export class FilesModule {}
```
{: file='*.module.ts' }

위 코드에서 `providers`의 배열에 Provider를 등록하면 IoC 컨테이너가 인지할 수 있다. 등록 시 IoC 컨테이너가 클래스를 인지하고 인스턴스 생성을 알아서 해주게 된다.
<br>

### Injectable 데코레이터
```ts
@Injectable()
export class FilesService {
  ...
}
```
{: file='*.service.ts'}

Provider로 사용하려면 위 코드처럼 `@Injectable()`를 붙여주면 좋다. <br>
안붙여도 `providers` 배열에 등록된 클래스는 인식을 하긴 하는데, 아래와 같은 이유 때문에 정상적으로 사용하려면 붙이는게 좋다.
- 생성자에 다른 의존성이 있을 경우 (블로그 업로드 기준으로 아래 2가지는 내가 이해를 못한다. 이해할 경우 다시 읽어보자.)
- 리플렉션 기반 메타데이터가 필요한 경우
- 스코프(Request/Transient)를 사용하는 경우
<br><br>



## 정리
NestJS는 인스턴스 생성을 개발자가 생성하지 않는다. IoC 컨테이너가 Provider를 생성하고, 필요한 곳에 자동으로 주입해준다. <br>
자동 주입을 사용하려면 Provider를 사용하려는 곳에 @Injectable() 데코레이터를 사용하고 *.module.ts 파일에 `providers` 배열에 등록만 해주면 된다.