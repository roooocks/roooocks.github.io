---
title: Object를 다루는 기능들
description: JS에서 오브젝트 가지고 놀아보기
date: 2025-10-02 17:21:00 +0900
categories: [프론트엔드, JS/TS]
tags: [프론트엔드, JS, JS 문법]
---

## 출처
모든 예제의 출처는 mdn입니다. <br>
mdn은 신이야!!


## 객체의 키-값
3가지의 함수 전부 배열을 값으로 반환시킨다. <br>
Object.keys, Object.values는 객체의 키, 값만 모아서 배열로 반환한다면 Object.entries는 [키, 값] 쌍을 요소로 가지는 배열로 반환한다.

### Object.keys
```js
/// 열거 가능한 속성이 아니라면 배열에 포함되지 않는다.
/// 넣고 싶다면 getOwnPropertyNames를 사용해야 한다.

// 일반 예제
const object1 = {
  a: "somestring",
  b: 42,
  c: false,
};

console.log(Object.keys(object1)); // 값: ["a", "b", "c"]

// 단순 배열
const arr = ["a", "b", "c"];
console.log(Object.keys(arr)); // ['0', '1', '2']

// 키와 순서가 무작위인 유사 배열 객체. 자동으로 정렬된다.
const anObj = { 100: "a", 2: "b", 7: "c" };
console.log(Object.keys(anObj)); // ['2', '7', '100']
```
{: file='Object.keys 예제' }

### Object.values
```js
/// 열거 가능한 속성이 아니라면 배열에 포함되지 않는다.

// 일반 예제
const object1 = {
  a: "somestring",
  b: 42,
  c: false,
};

console.log(Object.values(object1)); // 값: ["somestring", 42, false]

// 객체가 아니라면 객체로 강제 변환되어 적용
console.log(Object.values("foo")); // ['f', 'o', 'o']
```
{: file='Object.values 예제' }

### Object.entries
```js
/// 열거 가능한 속성이 아니라면 배열에 포함되지 않는다.

// 일반 예제 1
const object1 = {
  a: "somestring",
  b: 42,
};

for (const [key, value] of Object.entries(object1)) {
  console.log(`${key}: ${value}`);
}
// 값
// "a: somestring"
// "b: 42"

// 일반 예제 2
const obj = { foo: "bar", baz: 42 };
console.log(Object.entries(obj)); // [ ['foo', 'bar'], ['baz', 42] ]

// 키와 순서가 무작위인 유사 배열 객체. 자동으로 정렬된다.
const anObj = { 100: "a", 2: "b", 7: "c" };
console.log(Object.entries(anObj)); // [ ['2', 'b'], ['7', 'c'], ['100', 'a'] ]

// 객체가 아니라면 객체로 강제 변환되어 적용
console.log(Object.entries("foo")); // [ ['0', 'f'], ['1', 'o'], ['2', 'o'] ]
```
{: file='Object.entries 예제' }


## 배열 to 객체
**Object.fromEntries** <br>
솔직히 잊을만하면 나올 법한 함수일 것 같아서 적었다.
```js
/// 총 2가지 방식
// Map에서 Object
const entries = new Map([
  ["foo", "bar"],
  ["baz", 42],
]);

// Array에서 Object
const arr = [
  ["0", "a"],
  ["1", "b"],
  ["2", "c"],
];

// fromEntries 진행
const obj = Object.fromEntries(entries);

console.log(obj); // 값: { foo: "bar", baz: 42 }
```
{: file='Object.fromEntries 예제' }

```js
const object1 = { a: 1, b: 2, c: 3 };

const object2 = Object.fromEntries(
  Object.entries(object1).map(([key, val]) => [key, val * 2]),
);

console.log(object2); // { a: 2, b: 4, c: 6 }
```
{: file='Object.fromEntries 심화 버전' }


## 그 외
추가로 알아야 할 게 있다면 그때마다 여기에 적어두도록 하자

### Object.is
두 값이 같은 값인지를 확인하는 함수로 조건은 아래와 같다.
- 둘 다 undefined이나 null
- 둘 다 true나 false
- 둘 다 같은 순서로 같은 문자에 같은 길이인 문자열
- 둘 다 같은 객체(두 값 모두 **메모리에서 같은 객체를 참조**하는 것을 의미)
- 둘 다 숫자이면서...
  - 둘 다 +0이나 -0
  - 둘 다 NaN
  - 둘 다 0이나 NaN이 아니면서, 같은 값을 지님
때문에 "=="(양 쪽에[같은 형이 아니라면] 다양한 강제[coercion]를 적용한다고 한다.) 나 "==="(-0과 0을 같게 처리하고 NaN은 서로 같지 않게 처리한다.)와 같지 않다.

```js
// Case 1: 평가 결과는 ===을 사용한 것과 동일합니다
Object.is(25, 25); // true
Object.is("foo", "foo"); // true
Object.is("foo", "bar"); // false
Object.is(null, null); // true
Object.is(undefined, undefined); // true
Object.is(window, window); // true
Object.is([], []); // false
const foo = { a: 1 };
const bar = { a: 1 };
const sameFoo = foo;
Object.is(foo, foo); // true
Object.is(foo, bar); // false
Object.is(foo, sameFoo); // true

// Case 2: 부호 있는 0
Object.is(0, -0); // false
Object.is(+0, -0); // false
Object.is(-0, -0); // true

// Case 3: NaN
Object.is(NaN, 0 / 0); // true
Object.is(NaN, Number.NaN); // true
```
{: file='Object.is 예제' }

