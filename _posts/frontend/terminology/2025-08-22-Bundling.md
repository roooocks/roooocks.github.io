---
title: Bundling
description: Webpack, Vite만 알고있음...
date: 2025-08-25 17:28:00 +0900
categories: [프론트엔드, 앞단용어]
tags: [프론트엔드, React, 앞단용어]
---

인프런에 있는 **타입스크립트로 배우는 리액트(React.js) : 기초부터 최신 기술까지 완벽하게**와 **제미니**에게 물어본 내용을 요약했습니다.

## 쓰게 된 배경
- 프론트엔드의 규모가 커질수록 JS의 복잡도도 그만큼 증가하게 된다.
- 이를 위해 ES6에서는 JS Modules(ES 모듈)을 지원했다.
- "import", "export"를 활용해 코드를 여러 파일로 분리하는게 가능하게 되면서, 기능별로 파일을 쪼갤 수 있게 되었다.
- 여기서 아래와 같은 상황들로 인해 문제가 하나 터지는데...
  - 프로젝트의 규모가 커질수록 쪼개지는 파일의 수 역시 많아진다.
  - 모든 브라우저가 ES6을 지원하는건 아니였다.
  - 이 둘의 상황으로 <ins>많은 파일의 수(모듈)로 인한 네트워크 요청의 증가</ins>라는 **문제**가 발생하게 된다.
- 이 문제 해결을 위해 나온 방식이 <ins>여러 모듈을 하나 혹은 소수의 파일로 합치기</ins>이고 이걸 **번들링**이라 부른다.
- 대표적인 방식이 내가 학교에서 배웠던 **Webpack**이다.
- 물론 이전에도 Browserify(파일 통합에 집중), Grunt(파일 통합 + 코드 압축, 이미지 최적화 등) 등이 있었다.


## 주로 뭘 쓸까?
- 현재 블로그를 작성하고 있는 시점에서는 Webpack과 Vite가 대표적이라고 한다.
- 그 외에는 2가지가 있다.
  - Rollup
    - 주로 라이브러리 개발에 사용
    - 트리 쉐이킹 기능이 매우 뛰어나 <ins>최종 번들 크기를 최소화하는것</ins>에 **강점**
    - Vite의 빌드 엔진으로도 사용
  - esbuild
    - Go 언어로 작성, 번들링 속도가 압도적으로 빠르다.
    - Webpack, Vite의 일부 기능에 esbuild를 사용되기도 한다.


## Webpack, Vite
여기서 나오는 **HRM(Hot Module Replacement)** 는 <ins>새로고침 없이 즉시 반영해주는 기술</ins>을 의미한다.

### Webpack
- 특징
  - 거의 모든 종류의 파일을 모듈로 취급해 번들링
  - 오랜 시간 프론트엔드 생태계의 표준으로 자리를 잡았다. 때문에 플러그인이 방대하고 로더 생태계를 통해 복잡한 빌드 환경을 자유롭게 구성 가능

- 장점
  - **높은 커마** : 복잡, 다양한 요구 사항을 가진 대규모 프로젝트에 적합(이건 단점으로도 작용)
  - **풍부한 생태계** : 정말 많은 플러그인과 로더가 존재해 다양한 기능 구현이 쉽다.
  - **안정성** : 오랜 시간 동안 사용되었기에 많은 문제 해결과 커뮤니티 지원이 활발

- 단점
  - **복잡한 설정** : 초기 설정이 복잡..
  - **상대적으로 느린 속도** : 모든 파일을 번들링하기 때문에 개발 서버 구동, 빌드 속도가 느리다.

### Vite
- 특징
  - Webpack의 느린 속도를 개선하기 위해 나온 번들러
  - 현대 브라우저들은 ES 모듈(ESM)을 네이티브하게 지원하기 때문에 번들링 X, 필요한 모듈만 즉시 웹 브라우저를 통해 로드하는 방식 (개발 서버 구동, HMR 속도 빠름의 원인)
  - 개발 시 esbuild로 빠른 트랜스컴파일 수행, 프로덕션 빌드 시 Rollup을 사용해 최적화된 번들을 생성한다. (개발 속도 증가, 프로덕션 안정성 확보)
- 장점
  - **매우 빠른 속도** : 개발 서버 구동, HRM 속도가 Webpack보다 빠르다
  - **간편 설정** : 기본 설정만으로 대부분의 기능 사용이 가능
  - **Rollup 기반의 최적화 빌드** : 실제 배포용 빌드는 Rollup을 사용해 높은 성능의 번들 생성
- 단점
  - Webpack 보다 플러그인이 적다.
  - ESM 지원을 안하는 구형 브라우저를 위해 추가 설정이 필요할 수 있음 (중요!)
    - **프로덕션 환경의 해결법** : @vitejs/plugin-legacy 같은 플러그인 사용 (작성 기준으로는 이 플러그인이 구형 브라우저 호환성을 위한 최선의 방법)
    - **개발 환경의 해?결?법** : ESM을 지원하는 최신 브라우저가 필수다. 지원 안하면 실행 불가임;;
- 추가 설명
  - **SWC**라는게 있는데, 이게 <ins>타입 스크립트를 사용하는 대규모 프로젝트, 복잡한 바벨 설정 등이 필요할 때 사용</ins>하면 좋다.
  - 개발자의 선택지를 넓히기 위해 지원하는 것으로, 이건 Rust로 작성되었다고 한다.
  - 다만 사용하려면 별도의 플러그인이 필요하다고 한다.


## 뭘 써야해?
- 블로그 작성 기준으로는 Vite가 사용률이 매우 빠르게 증가하고 있다.
  - CRA가 deprecated가 되면서 다들 Vite를 새로운 프로젝트의 기본 도구로 사용하고 있다고 한다. 아마 이게 영향이 꽤 큰듯하다.
  - 또한 브라우저들이 예전과는 다르게 ES Modules를 지원하는것도 한 몫 할 것이다.
- 그렇다고 Webpack이 안쓰이는건 아닌게, Vite 전에는 Webpack이 대표적 번들러였기에 기존의 프로젝트들에는 사용해야한다. 또한 복잡한 프로젝트, 세밀한 제어가 필요한 경우 역시 많이 사용된다고 한다.
- **결국 상황에 맞게 쓰는게 좋다!**